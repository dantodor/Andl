// Andl samples 5 -- ordering and grouping
// NOTE: -- not yet implemented on SQL

// Depends on catalog created by setup.andl
#catalog

// Total and grouped subtotal
S .{ SS := fold(+,STATUS) }
S .{ CITY, SS := fold(+,STATUS) }

// In city order
// Since there is only one group, this produces running sum
S  .order(CITY) .{ SS := fold(+,STATUS) }
S  .order(CITY) .{ CITY, SS := fold(+,STATUS) }

// Add grouping by CITY to get separate subtotals
S  .order(%CITY) .{ SS := fold(+,STATUS) }
S  .order(%CITY) .{ CITY, SS := fold(+,STATUS) }

sum(n:0) => fold(+,n)
hi(n:0) => fold(max,n)
lo(n:0) => fold(min,n)
ave(n:0) => fold(+,n)/fold(+,1)

// --- ordered extension - means extension with access to other rows
// ordered on CITY but no grouping, so all in one group
S  .order(CITY) .{ *  
    ord:=ord(),     // unique index based on input, not output
    ordg:=ordg(),   // ord value for first member of group
    lag:=lag(STATUS,1),     // previous value in group, or default
    lead:=lead(STATUS,1),   // next value in group, or default
    nth:=nth(STATUS,1),     // nth value in group, or default
} 
// ordered and grouped on CITY
S  .order(%CITY) .{ *  
    ord:=ord(),
    ordg:=ordg(),
    lag:=lag(STATUS,1), 
    lead:=lead(STATUS,1), 
    nth:=nth(STATUS,1), 
} 
// ordered and grouped on CITY descending, with subtotalling/running sum
S  .order(%-CITY) .{ *  
    ord:=ord(),
    ordg:=ordg(),
    lag:=lag(STATUS,1), 
    lead:=lead(STATUS,1), 
    nth:=nth(STATUS,1), 
    sum:=sum(STATUS),    // running sum within group
    max:=hi(STATUS),
    min:=lo(STATUS),
    ave:=fold(+,STATUS)/fold(+,1),
} 

// end
