// sudoku-orig.andl -- direct translation of algorithm in Sqlite https://www.sqlite.org/lang_with.html

// brute force solver
// too slow -- breadth first

inp := {{ sud := '53..7....6..195....98....6.8...6...34..8.3..17...2...6.6....28....419..5....8..79' }}
digits := {{ z:= '1', lp := 1}} .while( {{ z:=text(lp+1), lp:=lp+1 }} .where(lp <= 9) )
inp
digits
x := inp 
    { s := sud, ind := before(sud, '.').length }
     .while(
    digits .{ s := left(s,ind) & z & right(s, 80-ind), ind, z, lp } [
        ?( ind < 7
            and not (z = right(left(s, (ind - 1) div 9 * 9 + lp), 1)
            or z = right(left(s, (ind - 1) mod 9 + (lp - 1) * 9 + 1), 1)
            or z = right(left(s, (ind - 1) div 3 mod 3 * 3 
                 + (ind - 1) div 27 * 27 
                 + lp + (lp - 1) div 3 * 6), 1)
            ))
        { s, ind := before(s, '.').length }
    
)
x
x.count


//WITH RECURSIVE
//  input(sud) AS (
//    VALUES('53..7....6..195....98....6.8...6...34..8.3..17...2...6.6....28....419..5....8..79')
//  ),
//  digits(z, lp) AS (
//    VALUES('1', 1)
//    UNION ALL SELECT
//    CAST(lp+1 AS TEXT), lp+1 FROM digits WHERE lp<9
//  ),
//  x(s, ind) AS (
//    SELECT sud, instr(sud, '.') FROM input
//    UNION ALL
//    SELECT
//      substr(s, 1, ind-1) || z || substr(s, ind+1),
//      instr( substr(s, 1, ind-1) || z || substr(s, ind+1), '.' )
//     FROM x, digits AS z
//    WHERE ind>0
//      AND NOT EXISTS (
//            SELECT 1
//              FROM digits AS lp
//             WHERE z.z = substr(s, ((ind-1)/9)*9 + lp, 1)
//                OR z.z = substr(s, ((ind-1)%9) + (lp-1)*9 + 1, 1)
//                OR z.z = substr(s, (((ind-1)/3) % 3) * 3
//                        + ((ind-1)/27) * 27 + lp
//                        + ((lp-1) / 3) * 6, 1)
//         )
//  )
//SELECT s FROM x WHERE ind=0;
//
