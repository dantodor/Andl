// Databases, Types and the Relational Model

#include SupplierData.andl
S
P
SP

// p 40
// EXTEND S ADD ( 3 * STATUS AS TRIPLE )

S [{*TRIPLE:=3*STATUS}]

// p41
// SUMMARIZE SP PER ( S { S# } ) ADD ( COUNT ( ) AS P_COUNT )

(S join SP) [{ S#, P_COUNT := fold(+,1) }]                  // wrong: only 4 rows
S [{ S#, P_COUNT := ( {{*}} join SP ) [{ fold(+,1) }] }]    // right: 5 rows

// p42
// SUMMARIZE S BY { CITY } ADD ( AVG ( STATUS ) AS AVG_STATUS )

S [{ CITY, AVG_STATUS := fold(+,STATUS)/fold(+,1) }]

// p42
// COUNT ( S ) /* result 5 */
// COUNT ( S { CITY } ) /* result 3 */
// AVG ( S { STATUS }, STATUS ) /* result 20 */
// AVG ( S, STATUS ) /* result 22 */

count(S)
count(S[{CITY}])
S[{STATUS}] [{ fold(+,STATUS)/fold(+,1) }]
S[{ fold(+,STATUS)/fold(+,1) }]

// p182 - Transitive closure by recursion

//OPERATOR TRANCLO ( XY RELATION { X P#, Y P# } ) RETURNS RELATION { X P#, Y P# } ;
//RETURN ( WITH ( XY UNION ( ( XY RENAME ( Y AS Z ) ) COMPOSE
//        ( XY RENAME ( X AS Z ) ) ) ) AS TTT :
//        IF TTT = XY THEN TTT /* unwind recursion */
//        ELSE TRANCLO ( TTT ) /* recursive invocation */
//        END IF ) ;
//END OPERATOR ;
//
//( TRANCLO ( MM RENAME ( MAJOR_P# AS X , MINOR_P# AS Y ) ) )
//RENAME ( X AS MAJOR_P# , Y AS MINOR_P# )

MM := {{ MAJOR_P#:text,MINOR_P#:text}
    ( "P1", "P2" ),
    ( "P1", "P3" ),
    ( "P2", "P3" ),
    ( "P2", "P4" ),
    ( "P3", "P5" ),
    ( "P4", "P6" )
}

XYT := {{X:='',Y:=''}}
TRANCLO:XYT(XY:XYT) => do {
        $TTT := XY[{*Z := Y}] compose XY[{*Z := X}] union XY
        if($TTT = XY, $TTT, TRANCLO($TTT))
    }
TRANCLO(MM[ {X:=MAJOR_P#, Y:= MINOR_P# } ]) [{MAJOR_P#:=X, MINOR_P#:=Y }]
