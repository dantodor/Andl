//################################################################################################################
//#noisy 1

db enrolment(csv), is_called(csv), is_enrolled_on(csv), course(csv), exam_mark(csv)

//exam_mark [?(StudentId = 'S1')]
//exam_mark [{StudentId, CourseId, Mark, double :=Mark*2,treble:=Mark*3,square:=Mark*Mark}]
exam_mark [ { StudentId, totalmark := fold(+,Mark) } ]
//exam_mark [ { Mark, CourseId, marks := {{ Mark }} } ]
#stop

// Basic smoke test

'hello world!'
v := 'hello world!'
v = 'hello world!'

'"' "Hel""lo" h'20' 'World' '!' h'0022' = '"Hello World!"'
"Hello" & d'32' & "World" = 'Hello World'
"Number: " & (17+22) & " Date: " & '31/12/2015' & " Bool: " & (6=6) = "Number: 39 Date: 31/12/2015 Bool: true"
"01/01/2015" < "31/12/2014"
t'01/01/2015' > t'31/12/2014'
i':=' "''" d'32' := b'2a2b2cd1e2f3'
i':=' h'27 0027 20' = b'2A2B2CD1E2F3'

s := 'abcdef'
s.length

if(true,"yes",'no')
if(false,0,1+2)
if(1>0,0,1+2)

v1 := 2+3
v1
dd => 1+2
dd
d2 => seq(2)
d2
d3(fred:0) => seq(fred)
d3(4)
fact:0(n:0) => if(n<=1,1,n*fact(n-1))
fact(20)
pot:0(n:0) => if(n<=0,1,10*pot(n-1))
pot(20)

// relational
{{}}
{{}} [?(false)]
{name := 'Smith', age := 17}
{{name := 'Smith', age := 17}}
{{name := 'Smith', age := 17},{name := 'Jones', age := 35},{age :=199,name:='Frankenstein' }}

{{:}}
{{:}()}
{{name:'',age:0}('Smith', 17)}
{{name:text,age:number}('Smith', 17)}
{{name:'',age:0} ('Smith', 17),('Jones', 35),('Frankenstein',199) }

db enrolment(csv), is_called(csv), is_enrolled_on(csv), course(csv), exam_mark(csv)
db S(csv), P(csv), SP(csv)

write(S.pp)
write(S[{CITY}].pp)

SP .schema
SP.count

// relational functions
seq(5) [{nnn := 17 + N * 0.3}]
schema(is_called)

// dyadics
course[{CID := CourseId }]
exam_mark [{CourseId}]
exam_mark [{*CourseId}]

exam_mark [?(StudentId = 'S1')]
exam_mark [{StudentId, CourseId, Mark, double :=Mark*2,treble:=Mark*3,square:=Mark*Mark}]
exam_mark [ { StudentId, totalmark := fold(+,Mark) } ]
exam_mark [ { Mark, CourseId, marks := {{ Mark }} } ]

course join exam_mark
course ajoin exam_mark
course union exam_mark

exam_mark sub exam_mark
not(exam_mark sub exam_mark[?(StudentId='S1')])
exam_mark sup exam_mark[?(StudentId='S1')]
not(exam_mark sep exam_mark)
exam_mark[?(StudentId='S1')] sep exam_mark[?(StudentId <>'S1')]

course join exam_mark [{CourseId}]
course join exam_mark [{*CourseId}]
(course join exam_mark) [{CourseId}]
(course join exam_mark) [{*CourseId}]

exam_mark [ { StudentId, CourseId, marks := {{ Mark := Mark }} } ]
//exam_mark [ { StudentId, totalmark := sum(Mark) } ] //???

exam_mark [ { StudentId, totalmark := fold(+,Mark) } ]
exam_mark [ { StudentId, totalmark := fold(+,Mark), avgmark := fold(+,Mark)/fold(+,1) } ]
exam_mark [ { StudentId, marks := fold(union,{{ Mark := Mark }}) } ]
exam_mark [ { StudentId, marks := fold(union,{{ CourseId := CourseId, Mark := Mark }}) } ]
exam_mark [ { StudentId, highmark := fold(max,Mark), lowmark := fold(min,Mark), ratio := fold(max,Mark)/fold(min,Mark) } ]

exam_mark [ ?({{ x := Mark }} = exam_mark [{ x := fold(min,Mark) }]) ]

xx := course [{ CourseId, ExamResult := {{ CourseId }} joinlr exam_mark}]
xx
xx [{ExamResult}]
xx [{ exres := fold(union,ExamResult) }]
xx [{ fold(union,ExamResult) }]

course [{ CourseId, ExamResult := {{ * }} joinr exam_mark}]

// updates
up1 => exam_mark := union {{StudentId:='fred', CourseId:='pub', Mark:=99}}
up2 => exam_mark := [ ?(StudentId = 'S1')]
up3 => exam_mark := [ ?(StudentId = 'fred') {* Mark := 100 }]
exam_mark
up1
exam_mark
up2
exam_mark
up3
exam_mark

// Ordered
P[$(WEIGHT)]
P[$(COLOR,-WEIGHT)]

// employees
db employee(csv)
employee [ $(%dep_name,-age) { *
    ord:=ord(),
    ordg:=ordg(),
    lagsal:=lag(salary,1), 
    leadsal:=lead(salary,1), 
    nthsal:=nth(salary,1), 
    salsum:=fold(+,salary),
    count:=fold(+,1)
}]

// Transitive closure
db MM(csv)
MM
XYT := {{X:='',Y:=''}}
TRANCLO:XYT(XY:XYT) => do {
        TTT := XY[{*Z := Y}] compose XY[{*Z := X}] union XY
        if(TTT = XY, TTT, TRANCLO(TTT))
    }
TRANCLO(MM[ {X:=MAJOR_P#, Y:= MINOR_P# } ]) [{MAJOR_P#:=X, MINOR_P#:=Y }]
