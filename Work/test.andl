#noisy 2
var S(csv), P(csv), SP(csv)
vs:='asdf'
vn := 99
vt := { x:=17, y:=21 }
vr := {{ x:=33, y:=51 }}
def udt(city:'', size:0)
vu := udt('Paris',20)

#noisy 3
vt .x
S .{ fold(+,STATUS) } 

#stop
vr
update vr union {{ x:=34, y:=599 }}
vr
update vr .where(x=34) .{ *x:=35 }
vr
update vr .where(x=33) .delete
vr
{{ X := 0 }} .while (S .where(X<100) .{ X := X + STATUS }) .where(X>=100)
S .order(CITY)
  .{ CITY, qty:=fold(+,STATUS) }
S .order(CITY) .where(STATUS>=20)
S .where(STATUS>=20) .order(CITY) 
S.order(CITY)
S.where(STATUS>20)
S.count
vt.x
#stop

{}
{name := 'Smith', age := 17}
{name := vs, age := vn}

tup(vt)
tup(vr)
tup(vu)
tup({name := 'Smith', age := 17})
tup({name := vs, age := vn})

{{name := 'Smith', age := 17},{name := 'Jones', age := 35},{age :=199,name:='Frankenstein' }}
{{name := vs, age := 17},{name := 'Jones', age := vn},{age :=199,name:='Frankenstein' }}
rel(vr)
rel(vt)
rel(vu)
rel({name := 'Smith', age := 17},{name := 'Jones', age := 35},{age :=199,name:='Frankenstein' })
#stop

// Relations - used heavily
{{:}}       // empty relation, no attributes, no tuples
{{:}()}     // ditto, one tuple
{{}}        // same, with type derived by inference
//{{},{},{},{},{},{},{},{}}        // exactly the same value (duplicates discarded)
{{:}(),(),(),(),(),(),()}         // exactly the same value (heading format)
wait

// Relation literal can be just a comma separate list of tuples
// all the same -- order does not matter
{{name := 'Smith', age := 17},{name := 'Jones', age := 35},{age :=199,name:='Frankenstein' }}
{{name := 'Smith', age := 17},{age :=199,name:='Frankenstein' },{age := 35, name := 'Jones'}}

// or it can have a header and a list of selectors with values in the same order
{{name:text,age:number}
    ('Smith', 17),
    ('Jones', 35),
    ('Frankenstein', 199)
}

#stop
// test.andl -- is automatically loaded and run if no other file is specified
// 
// Use this for quickly testing out ideas
#noisy 1

'testing 1,2,3,4...'
x:=42
x
seed := {{ name:= 'Alice', level := 0 }}
seed

db S(csv), P(csv), SP(csv)
S
S [{}]
S [ { fold(+,STATUS) } ]    // aggregated value

suppliers := S [{ *Sid:=S# }]
parts := P [{ *Pid := P# }]
supplies := SP [{ *Sid := S#, Pid:= P# }]
sandsp := S [{ * sp := {{*}} compose SP}]
parts
sandsp

fact:number(n:number) => if(n < 2, n, n * fact(n-1))
fact(7)
fib:number(n:number) => if(n < 2, n, fib(n-1) + fib(n-2))
fib(7)
tfact(n:number) => do {
  t := now().number
  fact(20)
  1000*(now().number-t)
}
tfact(50)

t:=now()
def utx(b:bool, s:text, n:number, t:time, r:{{a:text,b:text}})
utv:=utx(true,'hello world', 42, now(), {{a:='aaaa',b:='bbbb'},{a:='aaaaa',b:='bbbbb'}})

{{ X := 0 }} recurse (S [?(X<1000) { X := X + STATUS }]) [?(X>=1000)]

suppliersbyname(name:text) => S [ ?(SNAME =~ name) { *Sid:=S# }] 
suppliersbyname('a')
addsuppliers(adds:S) => S := union adds

addsuppliers({{ S#:='S99', SNAME:="Freddo", STATUS:=99, CITY:="Ur"}})

S [ { fold(+,STATUS) } ]    // aggregated value

_vartext := 'testing 1,2,3,4...'
_varnum := 42.00
_varrel := { {name:text,age:number}('Smith', 17),('Jones', 35),('Frankenstein', 199) }
_func(a:'') => do { a }
def _udt(b:bool, s:text)

vartext := _vartext
varnum := _varnum
varrel := _varrel
@varrel := _varrel
func(a:'') => do { a }
def udt(b:bool, s:text)
udv := udt(true, 'not false')

//andl_catalog

VR:={{ S#:='S99', SNAME:="Freddo", STATUS:=99, CITY:="Ur"}}
VT:={ S#:='S99', SNAME:="Freddo", STATUS:=99, CITY:="Ur"}
VT.S#

VR [{SNAME, X:=99}]
VT [{SNAME, X:=99}]
sum(n:0) => fold(+,n)
hi(n:0) => fold(max,n)
lo(n:0) => fold(min,n)
ave(n:0) => fold(+,n)/fold(+,1)

S [ { sum(STATUS) } ]    // aggregated value
S [ { sum(STATUS)/lo(STATUS) } ]    // aggregated value

S [ { partition := {{*}} join SP } ]
S [ { S#, SNAME, SUMQTY := ( {{*}} join SP ) [ { fold(+,QTY) } ] } ]

(S join SP) [ { S#, SNAME, SUMQTY := fold(+,QTY) } ] union (S ajoin SP) [ { S#, SNAME, SUMQTY := 0 } ]
(S join SP) [ { S#, SNAME, SUMQTY := fold(+,QTY).text } ] union (S ajoin SP) [ { S#, SNAME, SUMQTY := '--' } ]

SP400 := SP [ ?(QTY>=400) ]
(S join SP400) [ { S#, P# } ] union (S ajoin SP400) [ { S#, P# := 'none' } ]

artist  := {{ artistid:0, name:'' }}
cd      := {{ cdid:0, artistid:0, title:'', year:0 }}
track   := {{ trackid:0, cdid:0, title:'' }}

// some data in temporary relvars, with auto-generated ordinals
$artist_data := {{name:''}
  ( 'Michael Jackson' ), 
  ( 'Eminem' ),
} [{ *artistid := ord() }]

get_S_keys() => do {
    S [ { S# } ]
}
get_S_keys()

getSid(id:0) => do {
    S [ ?(S#=id) ]
}
getS() => do {
    S
}
putSid(id:0,s:S) => do {
    S := [ ?(S#=id) ]
    S := union s
}
putS(s:S) => do {
    S := union s
}

//andl_catalog
//andl_variable()
//andl_operator()
//andl_member()

@paste(s1, s2) => if(s1='',s2 , s1 & ', ' & s2)

mem := andl_member() [{ 
    K := MemberOf, 
    V := fold(@paste, Name & ':' & Type)
}] union {{ K := '', V := '' }}

op1 := (andl_operator() join mem[{ * Members := K }]) [{ Name, Type, Attributes := V, A := Arguments }]
op2 := (op1 join mem[{ A := K, Arguments := V }]) union (op1[{ * Arguments := '' }] ajoin mem[{ A := K }])
op2 [ $(Name) { Name, Type, Attributes, Arguments }]

b := binary(100)
b.blength

S [?(CITY='Paris' and STATUS > 0 or
true) 
    {STATUS}] 
