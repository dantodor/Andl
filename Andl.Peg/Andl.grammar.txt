// Andl grammar - Pegasus
// See: https://github.com/otac0n/Pegasus/wiki/Syntax-Guide

@namespace Andl.Peg
@classname PegParser
@using System.Linq


// start rule
Main <AstBlock> = #STATE{ PrintLine(state); } WSE* v:MainBodyLine* WSO EOF { AST.Block(v) } ;
MainBodyLine <AstStatement> = !EOF DirectiveLine* v:StatementLine { v };
StatementLine <AstStatement> = WSO &EOF { null }
    / v:Statement EOLexp WSE+ { v };

DoBody <AstValue> = LC RC { AST.DoBody(null) }
    / LCexp v:DoBodyLine+ RCexp { AST.DoBody(v) };
DoBodyLine <AstStatement> = DirectiveLine* v:DoStatementLine { v };
DoStatementLine <AstStatement> = &RC { null}
    / v:Statement (&RC / EOLexp WSE+) { v };

//DoBody <AstValue> = v:DoBodyLine* &RC { AST.DoBody(v) };
//DoBodyLine <AstStatement> = !RC DirectiveLine* v:DoStatementLine { v };
//DoStatementLine <AstStatement> = &RC { null}
//    / v:Statement (&RC / EOLexp WSE+) { v };

DirectiveLine = Directive EOLexp WSE+;

// recovery rule
//Error = #STATE{ ParseError(state); } Skip EOL;
Skip = (!EOL .)* EOL;       // take EOL here to avoid printing line twice

// directives
Directive = "#" (CatalogDirective / IncludeDirective / NoisyDirective / StopDirective / PanicDirective / BadDirective);
CatalogDirective = "catalog" IDX v:CatalogOption* (&EOL / #STATE{ ParseError(state, "option expected"); } Skip ) { CatalogDirective(v) };
CatalogOption = v:("new" / "load" / "update") IDX { v };
IncludeDirective = "include" IDX v:(!CC .)* { IncludeDirective(String.Concat(v).Trim()) };
NoisyDirective = "noisy" IDX v:Integer { NoisyDirective(String.Concat(v)) };
StopDirective = "stop" IDX v:Integer? { StopDirective(String.Concat(v)) };
PanicDirective = "panic" IDX #ERROR{ "panic" };
BadDirective = #STATE{ ParseError(state, "bad directive");} Skip;

// statements
Statement <AstStatement> = WSO &. v:(<AstStatement> Deferred / Typedef / Import / UpdateJoin / UpdateTransform / Assignment / Expression / BadStatement) { v };

Typedef <AstDefine> = DEF v:(UserType / Subtype) { v };
UserType <AstDefine> = v:DefinableExp LP w:FieldList RPexp { AST.UserType(v, w.ToArray()) } ;
Subtype <AstDefine> = v:DefinableExp COLON w:Type { AST.SubType(v, w) };
Type <AstType> = v:Typename &{ IsTypename(v) } { AST.FindType(v) }
    / v:SimplePrimary { AST.Typeof(v) }
    / #STATE{ ParseError(state, "type expected"); } { null };

Import <AstBlock> = DB v:ImportSource<0,,SEP> { AST.Block(v) };
ImportSource <AstStatement> = v:DefinableExp LP w:SourceName RPexp { AST.Source(v, AST.Text(w)) };
SourceName = v:Ident  &{ IsSourceName(v) } { v }
    / &RP { "" }
    / #STATE{ ParseError(state, "source name expected"); } { "" };

Assignment <AstStatement> = &(Ident LA) v:DefinableExp LA w:OpenExpression { AST.Assignment(v,w) }
    / Definable LA #STATE{ ParseError(state, "expression expected"); } { null };

// must be able to backtrack from RA to pick up function call
Deferred <AstDefine> = v:Definable 
    w:(<AstType> COLON a:Type { a } / { null }) 
    x:(<IList<AstField>> LP b:FieldList RP { b })? RA 
    &{ DefScope(v, w, Single(x)) } y:DeferredBody &{ PopScope() } { AST.Deferred(v,w,Single(x),y) };

DeferredBody <AstStatement> = 
    (UpdateJoin 
    / UpdateTransform 
    / OpenAttrExpression 
    / BadStatement);

// prefer: &{ w.IsJoinOp() } 
UpdateJoin <AstStatement> = v:CatVar LA &("union" / "minus") w:Funcop x:ExpressionExp { AST.UpdateJoin(v,w,x) };
UpdateTransform <AstStatement> = v:CatVar LA &LB w:TransformTailExp { AST.UpdateTransform(v,w) };
BadStatement <AstStatement> = #STATE{ ParseError(state, "bad statement");} Skip { null };

TransformTailExp = TransformTail
    / #STATE{ ParseError(state, "transform arguments expected"); } { null };
TransformTail <AstValue[]> = LB v:Where? WSC w:Order? WSC 
        LC WSC x:STAR? WSC y:ProjectList RCexp RBexp { AST.TransformTail(Single(v), Single(w), x.Count > 0, y) }
    / LB v:Where? WSC w:Order? RBexp { AST.TransformTail(Single(v), Single(w), false, null) };

ProjectList = Project<0,,SEP>;
Project <AstProject> = &RC { null }
    / v:FieldIdent &(SEP / RC) { AST.Project(v) }
    / v:Definable LA w:FieldIdent &(SEP / RC) { AST.Project(v, w) }
    / v:Definable LA w:OpenAttrExprExp { AST.Project(v, null, w) }
    / v:OpenAttrExprExp { AST.Project(null, null, v) };

// expressions
OpenAttrExprExp = (OpenAttrExpression 
    / #STATE{ ParseError(state, "invalid attribute expression"); } { null });
OpenExpressionExp = OpenExpression
    / #STATE{ ParseError(state, "expression expected"); } { null };
ExpressionExp = Expression
    / #STATE{ ParseError(state, "expression expected"); } { null };

OpenAttrExpression = LookupExpression; // may have a fold
LookupExpression = OpenExpression;  // needs to do name lookup
OpenExpressionList = v:OpenExpression<0,,SEP>;
OpenExpression = Expression;  // expression may be passed as value
ExpressionList = v:Expression<0,,SEP>;
//Expression <AstValue> = v:Primary w:BinopCall* { AST.Expression(v,w) }; 
//BinopCall <AstOpCall> = x:Binop WSC y:Primary { AST.OpCall(x,y) } 
//Primary <AstValue> = v:SimplePrimary w:(Transform / Recurse / Dot)* { AST.Expression(v,w) };

Expression <AstValue> = v:Primary w:Binop WSC x:Expression { AST.FunCall(w,v,x) } 
    / Primary;
Primary <AstValue> -memoize = v:Unop w:Primary { AST.FunCall(v,w) }
    / v:Primary RECURSE LPexp w:OpenExpressionExp RPexp { AST.FunCall("recurse",v,w) }
    / v:Primary DOT w:FieldOrFuncExp { AST.FunCall(w,v) }
    / v:Primary &LB 
        &{ Check(IsRel(v), state, "relation type expected") }
        &{ PushRelScope(v) } w:TransformTailExp &{ PopRelScope() } { AST.Transform(v,w) }
    / SimplePrimary;

SimplePrimary = DoBlock 
    / LP v:Expression RPexp { v }
    / Table / Row
    / Fold / If
    / Function
    / v:Literal { v }
    / v:VarIdent  { AST.Variable(v) }
    / v:Ident #STATE{ ParseError(state, "undefined '{0}'", v); } { null };

//Transform = &LB TransformTailExp;

//Recurse <AstOpCall> = RECURSE LPexp v:OpenExpression RPexp { AST.OpCall("recurse", v) }
//    / RECURSE #STATE{ ParseError(state, "open expression expected"); } { null };

//Dot <AstOpCall> = DOT v:(FieldIdent / Funcop) { AST.OpCall(v) }
//    / DOT #STATE{ ParseError(state, "field or function expected"); } { null };

If <AstValue> = IF LPexp v:Expression SEPexp w:OpenExpression SEPexp x:OpenExpression RPexp { AST.FunCall("if", v, w, x) }
    / IF LP  #STATE{ ParseError(state, "expression expected"); } { null };

Fold <AstValue> = FOLD LPexp v:Foldableop SEPexp w:OpenExpression RPexp { AST.FunCall("fold", AST.FunCall(v), w) }
    / FOLD LP  #STATE{ ParseError(state, "fold operator expected"); } { null };

DoBlock <AstValue> = DO v:DoBody { v }

//DoBlock <AstValue> = DO LCexp v:DoBody RCexp { v }
//    / DO LC #STATE{ ParseError(state, "do body expected"); } { null };

Function <AstValue> = v:Funcop LP w:ExpressionList RPexp { AST.FunCall(v, w.ToArray()) };

Table <AstValue> = (TableBody 
    / LC LC #STATE{ ParseError(state, "invalid table body"); } { null } );
TableBody <AstValue> = LC LC COLON RCexp RCexp { AST.Table(false) }
    / LC LC STAR RCexp RCexp  { AST.Table(true) }
    / LC LC &(Ident !LA (COLON / SEP)) v:FieldList RCexp w:TableValueList RCexp { AST.Table(v,w) }
    / LC &LC v:RowList RCexp { AST.Table(null, v) };
TableValueList = v:TableValue<0,,SEP>;
TableValue <AstValue> = LP v:OpenExpressionList RPexp { AST.Row(v) };

RowList = v:Row<0,,SEP>;
Row <AstValue> = LC STAR RCexp { AST.RowStar() }
    / LC v:ProjectList RCexp { AST.Row(v) }
    / LC #STATE{ ParseError(state, "invalid attribute list"); } RCexp { null };

FieldList = v:FieldTerm<0,,SEP>;
FieldTerm <AstField> = v:Definable COLON w:Type { AST.Field(v, w) }
    / v:Definable { AST.Field(v, null) };

Where <AstValue> = QUERY LPexp v:LookupExpression RPexp { v };
Order <IList<AstOrder>> = DOLLAR LPexp v:OrderTermList RPexp { v};
OrderTermList = OrderTerm<0,,SEP>;
OrderTerm <AstOrder> = v:MINUS? w: PERCENT? x:FieldIdent { AST.Order(x, v.Count > 0, w.Count > 0) };

DefinableExp = Definable 
    / #STATE{ ParseError(state, "aleady defined"); } { null }
FieldOrFuncExp = FieldIdent / Funcop
    / #STATE{ ParseError(state, "field or function expected"); } { null }

Typename = v:Ident &{ IsTypename(v) } { v };
Foldableop = v:Funcop &{ IsFoldableop(v) } { v };
Binop = v:Funcop &{ IsBinop(v) } { v };
Unop = v:Funcop &{ IsUnop(v) } { v };
Funcop = v:(Ident / Operator) &{ IsFuncop(v) } { v };
FieldIdent = v:Ident &{ IsField(v) } { v };
VarIdent = v:Ident &{ IsVariable(v) } { v };
CatVar = v:Ident &{ IsCatVar(v) } { v };
Definable = v:Ident &{ IsDefinable(v) } { v };

// expecteds
LCexp = (WSC LC / #STATE{ ParseError(state, "left brace expected"); } );
RCexp = (WSC RC / #STATE{ ParseError(state, "right brace expected"); } );
RBexp = (WSC RB / #STATE{ ParseError(state, "right bracket expected"); } );
LPexp = (WSC LP / #STATE{ ParseError(state, "left parenthesis expected"); } );
RPexp = (WSC RP / #STATE{ ParseError(state, "right parenthesis expected"); } );
//LAexp = (WSC LA / #STATE{ ParseError(state, ":= expected"); } );
SEPexp = (WSC LA / #STATE{ ParseError(state, "comma expected"); } );
EOLexp = (&EOL / #STATE{ ParseError(state, "end of line expected"); } Skip );

// Terminals -- each swallows following whitespace
Ident = !KEYWORD v:(IdentName / IdentString TextString?) WSO { v };
Operator = v:OpSym WSO { v };
Literal<AstValue> = v:Literals WSO { v };
Literals<AstValue> = TRUE { AST.Bool("true") }
    / FALSE { AST.Bool("false") }
    / v:BinaryString { AST.Binary(v) }
    / v:NumberString { AST.Number(v) }
    / v:IntegerString { AST.Number(v) }
    / v:TimeString { AST.Time(v) }
    / v:TextString { AST.Text(v) };
Integer = IntegerString WSO;

KEYWORD = DO / DEF / DB / TRUE / FALSE / NOT;

// note: tokens followed by WSC will swallow an EOL
DB = "db" IDX;
DEF = "def" IDX;
DO = "do" IDX;

TRUE = "true" IDX;
FALSE = "false" IDX;
RECURSE = "recurse" IDX;
IF = "if" IDX;
FOLD = "fold" IDX;

NOT = "not" IDX;
RA = "=>" WSC;
LA = ":=" WSC;
COLON = ':' !OpChar WSC;
SEP = ',' WSC;
DOT = '.' WSO;
LC = '{' WSC;
RC = '}' WSO;   // note: gets its own handling
LP = '(' WSC;
RP = ')' WSO;
LB = '[' WSC;
RB = ']' WSO;
STAR = '*' !OpChar WSC;
QUERY = '?' WSO;
DOLLAR = '$' WSO;
PERCENT = '%' WSO;
MINUS = '-' !OpChar WSO;

IDX = !ID WS*;              // end of ident possibly followed by WS

WSO = WS*;                  // optional whitespace between tokens
WSC = WSO (EOLX WSO)?;      // continuation, take just one eol if found, plus WS
WSE = WSO EOLX;             // whitespace and take eol, leave at start of line
WS = (SP / Comment) { "" };
SP = [ \t];
Comment = "//" (!EOL .)*
        / "/*" (!"*/" (EOLX / .))* "*/";

EOLX = EOL #STATE{ PrintLine(state); }; // consumed EOL, so print it
EOL = "\r"? "\n" { "" };
EOF = !.;

// More complex lexical tokens, but not for use as terminals
TextString = v:(SingleQuoted / DoubleQuoted / CharHexQuoted / CharDecQuoted)+ { String.Concat(v) };
SingleQuoted = SQ v:("" (!(CC / SQ) . )* ) SQ { v };
DoubleQuoted = DQ v:("" (!(CC / DQ) . )* ) DQ { v };
CharHexQuoted = "h" SQ v:("" SP* (HexDigit+ SP*)*) SQ { v };
CharDecQuoted = "d" SQ v:("" SP* (Digit+ SP*)*) SQ { v };
BinaryString  = "b" SQ v:("" HexDigit*) SQ { v };
TimeString    = 't' SQ v:("" (Digit / Letter / TimeChar)+) SQ { v };
NumberString  = '.' Digit+ / Digit+ ('.' Digit*)?;
IntegerString = "" Digit+ / "$" Digit HexDigit*;
IdentString   = "i" SQ v:""( (!CC !SQ .)* ) SQ { v };
IdentName = (Letter / IdChar) (Letter / Digit / IdChar / IdCharX)*;
OpSym = OpChar OpChar?;
ID = Letter / Digit / IdChar / IdCharX;

// character sets (not tokens)
Letter = [a-zA-Z];
Digit = [0-9];
HexDigit = [a-fA-F0-9];
OpChar = [&=<>:~*/+-];
IdChar = [_$@^];
IdCharX = [#%&?!~`];
TimeChar = [: ./-];
CC = [\x00-\x1f];
SQ = "'";
DQ = '"';
