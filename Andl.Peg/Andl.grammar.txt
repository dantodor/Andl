// Andl grammar - Pegasus
// See: https://github.com/otac0n/Pegasus/wiki/Syntax-Guide

@namespace Andl.Peg
@classname PegParser
@using System.Linq


// start rule: Init for error handling, Start to load catalog
MainStart <AstStatement> = &{ PrintLine(state) } &{ SetState(state) } DirectiveOrBlank* &{ Start() } v:MainNext { v }
    / MainRestart;  // suppress warning -- never taken

// Continue after error
MainRestart <AstStatement> =  Skip v:MainNext { v }

// Parse just one blank line, directive, statement or block
MainNext <AstStatement> =  v:MainStatement &{ SetState(state) } { v };
MainStatement <AstStatement> = WSO EOFX { null }
    / DirectiveOrBlank v:MainStatement { v }
    / WSO v:Statement WSO (EOFX / EOLchk EOLX) { v };

// A do body is just {} or { statements }, EOF not allowed
DoBody <AstValue> = WSO LCexp &{ AST(state).Enter() } WSC v:DoBodyLine* &{ AST(state).Exit() } WSO RCexp { AST(state).DoBlock(v) };
DoBodyLine <AstStatement> = DirectiveOrBlank { AST(state).Empty() } // Note: DoBlock must discard these
    / !(WSO RC) v:Statement WSO (&RC / EOLchk EOLX) { v };

// directives
DirectiveOrBlank = BlankLine / DirectiveLine;
//DirectiveOrBlank <AstStatement> = (BlankLine / DirectiveLine)  { AST(state).Empty() };
BlankLine = WSO &EOL EOLX;
DirectiveLine = Directive WSO EOLchk EOLX;      // take directive and end of line

Directive = "#" (CatalogDirective / IncludeDirective / NoisyDirective / StopDirective / PanicDirective / BadDirective);
CatalogDirective = "catalog" IDX v:CatalogOption* (&EOL / #STATE{ ParseError(state, "option expected"); } ) { CatalogDirective(state, v) };
CatalogOption = v:("new" / "load" / "update") IDX { v };
IncludeDirective = "include" IDX v:(!CC .)* { IncludeDirective(state, String.Concat(v).Trim()) };
NoisyDirective = "noisy" IDX v:Integer { NoisyDirective(state, String.Concat(v)) };
StopDirective = "stop" IDX v:Integer? { StopDirective(state, String.Concat(v)) };
PanicDirective = "panic" IDX #ERROR{ "panic" };
BadDirective = #STATE{ ParseError(state, "bad directive");};

//--- statements
Statement <AstStatement> = v:(<AstStatement> Deferred / Typedef / Import / UpdateJoin / UpdateTransform / Assignment / Expression / BadStatement) { v };

Typedef <AstDefine> = DEF v:(UserType / Subtype)<0,,SEP> { AST(state).DefBlock(v) };
UserType <AstDefine> = v:DefinableExp LP w:FieldList RPexp { AST(state).UserType(v, w.ToArray()) } ;
Subtype <AstDefine> = v:DefinableExp COLON w:Type { AST(state).SubType(v, w) };
Type <AstType> = v:Typename &{ IsTypename(v) } { AST(state).FindType(v) }
    / v:SimplePrimary { AST(state).GetType(v) }
    / #STATE{ ParseError(state, "type expected"); } { null };

Import <AstBlock> = DB v:ImportSource<0,,SEP> { AST(state).Block(v) };
ImportSource <AstStatement> = v:DefinableExp LP w:SourceName RPexp { AST(state).Source(v, AST(state).Text(w)) };
SourceName = v:Ident  &{ IsSourceName(v) } { v }
    / &RP { "" }
    / #STATE{ ParseError(state, "source name expected"); } { "" };

Assignment <AstStatement> = &(Ident LA) v:DefinableExp LA w:Expression { AST(state).Assignment(v,w) }
    / Definable LA #STATE{ ParseError(state, "expression expected"); } { null };

// must be able to backtrack from RA to pick up function call
Deferred <AstStatement> = v:Ident 
    w:(<AstType> COLON a:Type { a } / { null }) 
    x:(<IList<AstField>> LP b:FieldList RP { b })? RA 
    &{ AST(state).Enter(v, w, Single(x)) } y:DeferredBody &{ AST(state).Exit(true) } { AST(state).Deferred(v,w,Single(x),y) };

DeferredBody <AstBodyStatement> = 
    v:(UpdateJoin 
    / UpdateTransform 
    / OpenAttrExpr 
    / BadStatement) { AST(state).BodyStatement(v) };

// prefer: &{ w.IsJoinOp() } 
UpdateJoin <AstStatement> = 
    v:CatVar LA &("union" / "minus") w:Funcop x:ExpressionExp
    { AST(state).UpdateJoin(v,w,x) };
UpdateTransform <AstStatement> = 
    v:CatVar LA &LB &{ AST(state).Enter(AST(state).Variable(v)) } w:TransformTailExp &{ AST(state).Exit(true) } 
    { AST(state).UpdateTransform(v,w) };
BadStatement <AstStatement> = #STATE{ ParseError(state, "bad statement");}  { null };

//----- expressions
OpenAttrExprExp = (OpenAttrExpr 
    / #STATE{ ParseError(state, "invalid attribute expression"); } { null });
ExpressionExp = Expression
    / #STATE{ ParseError(state, "expression expected"); } { null };

OpenAttrExpr = OpenExpression; // may have a fold
OpenExpression = Expression;  // needs to do name lookup
ExpressionList = v:Expression<0,,SEP>;

Expression <AstValue> = v:Primary w:BinopTail* { AST(state).Binop(v,w) } 
BinopTail <AstOpCall> = v:Binop WSC w:Primary { AST(state).OpCall(v,w) } 

Primary <AstValue> = "-" v:Primary { AST(state).Function("u-",v) }
    / v:Unop w:Primary { AST(state).Function(v,w) }
    / v:SimplePrimary &{ AST(state).Enter(v) } w:PostFixTail* &{ AST(state).Exit(true) } { AST(state).PostFix(v,w) };

PostFixTail <AstCall> = RECURSE LPexp v:ExpressionExp RPexp { AST(state).OpCall("recurse",AST(state).Number(0),v) }
    / &LB v:TransformTailExp { v }
    / DOT v:Funcop { AST(state).DotFunc(v) }
    / DOT v:Component { AST(state).DotComponent(v) }
    / DOT v:FieldIdent { AST(state).DotField(v) }
    / DOT #STATE{ ParseError(state, "component or function expected"); } { null };

//--- Transforms
TransformTailExp = TransformTail
    / LB #STATE{ ParseError(state, "transform arguments expected"); } { null };
TransformTail <AstTranCall> = LB v:Where? WSC w:Orderer? WSC x:Transformer? RBexp { AST(state).TransformTail(Single(v), Single(w), Single(x)) };

Where <AstValue> = QUERY LPexp v:OpenExpression RPexp { AST(state).Where(v) };

Orderer <AstOrderer> = DOLLAR LPexp v:OrderTermList RPexp { AST(state).Orderer(v) };
OrderTermList = OrderTerm<0,,SEP>;
OrderTerm <AstOrder> = w:PERCENT? v:MINUS? x:FieldIdent { AST(state).Order(x, v.Count > 0, w.Count > 0) };

Transformer <AstTransformer> = LC WSC v:STAR? WSC w:TransformList SEP? RCexp { AST(state).Transformer(v.Count > 0, w) }
TransformList = Transform<0,,SEP>;
Transform <AstField> = !RC v:FieldIdent &(SEP / RC) { AST(state).Transfield(v) }
    / !RC v:Ident LA WSC w:FieldIdent &(SEP / RC) { AST(state).Transfield(v, w) }
    / !RC v:Ident LA WSC w:OpenAttrExprExp { AST(state).Transfield(v, null, w) }
    / !RC v:OpenAttrExprExp { AST(state).Transfield(null, null, v) };

//----- Primaries
SimplePrimary = DoBlock 
    / LP v:Expression RPexp { v }
    / Table / Row
    / Fold / If
    / Function
    / v:Literal { v }
    / v:VarIdent  { AST(state).Variable(v) }
    / v:Ident #STATE{ ParseError(state, "undefined '{0}'", v); } { null };

If <AstValue> = IF LPexp v:Expression SEPexp w:Expression SEPexp x:Expression RPexp { AST(state).If(v,w,x) }
    / IF LP  #STATE{ ParseError(state, "expression expected"); } { null };

Fold <AstValue> = FOLD LPexp v:Foldableop SEPexp w:Expression RPexp { AST(state).Fold(v,w) }
    / FOLD LP  #STATE{ ParseError(state, "fold operator expected"); } { null };

DoBlock <AstValue> = DO v:DoBody { v }

Function <AstValue> = v:Funcop LP w:ExpressionList RPexp { AST(state).Function(v, w.ToArray()) };

Table <AstValue> = &(LC LC) &{ AST(state).Enter() } v:TableBody &{ AST(state).Exit() } { v }
    / LC LC #STATE{ ParseError(state, "invalid table body"); } { null };

TableBody <AstValue> = LC LC STAR RCexp RCexp  { AST(state).Table() }
    / LC &LC v:TableHeading WSC w:RowValueList SEP? RCexp { AST(state).Table(v,w) }
    / LC &LC v:RowList RCexp { AST(state).Table(null, v) };
TableHeading <AstValue> = LC COLON RC { AST(state).Heading(null) }
    / LC &(Ident COLON) v:FieldList RCexp { AST(state).Heading(v) };

RowValueList = v:RowValue<0,,SEP>;
RowValue <AstValue> = LP v:ExpressionList SEP? RPexp { AST(state).RowValues(v) };

RowList = v:Row<0,,SEP>;
Row <AstValue> = LC STAR RCexp { AST(state).Row() }
    / LC v:RowTransList RCexp { AST(state).Row(AST(state).Transformer(false, v)) }
RowTransList = RowTrans<0,,SEP>;
RowTrans <AstField> = v:FieldIdent &(SEP / RC) { AST(state).Transfield(v) }
    / v:Ident LA w:Expression { AST(state).Transfield(v, null, w) }

//----- definitions
FieldList = v:FieldTerm<0,,SEP>;
FieldTerm <AstField> = v:Definable COLON w:Type { AST(state).FieldTerm(v, w) }
    / v:Definable { AST(state).FieldTerm(v, null) };

DefinableExp = Definable 
    / #STATE{ ParseError(state, "aleady defined"); } { null }

Typename = v:Ident &{ IsTypename(v) } { v };
Foldableop = v:Funcop &{ IsFoldableop(v) } { v };
Binop = v:Funcop &{ IsBinop(v) } { v };
Unop = v:Funcop &{ IsUnop(v) } { v };
Funcop = v:(Ident / Operator) &{ IsFuncop(v) } { v };
Component = v:Ident &{ IsComponent(v) } { v };
FieldIdent = v:Ident &{ IsField(v) } { v };
VarIdent = v:Ident &{ IsVariable(v) } { v };
CatVar = v:Ident &{ IsCatVar(v) } { v };
Definable = v:Ident &{ IsDefinable(v) } { v };

// expecteds
LCexp = (WSC LC / #STATE{ ParseError(state, "left brace expected"); } );
RCexp = (WSC RC / #STATE{ ParseError(state, "right brace expected"); } );
RBexp = (WSC RB / #STATE{ ParseError(state, "right bracket expected"); } );
LPexp = (WSC LP / #STATE{ ParseError(state, "left parenthesis expected"); } );
RPexp = (WSC RP / #STATE{ ParseError(state, "right parenthesis expected"); } );
//LAexp = (WSC LA / #STATE{ ParseError(state, ":= expected"); } );
SEPexp = (WSC SEP / #STATE{ ParseError(state, "comma expected"); } );
EOLchk = (&EOL / #STATE{ ParseError(state, "end of line expected"); } );

// Terminals -- each swallows following whitespace
Ident = !KEYWORD v:IdentName WSO { v };
IdentName = v:IdentQuoted WSO w:TextString { v + w }
    / IdentQuoted 
    / IdentString;
Operator = v:OpSym WSO { v };
Literal<AstValue> = v:Literals WSO { v };
Literals<AstValue> = TRUE { AST(state).Bool("true") }
    / FALSE { AST(state).Bool("false") }
    / v:BinaryQuoted { AST(state).Binary(v) }
    / v:TimeQuoted { AST(state).Time(v) }
    / v:NumberString { AST(state).Number(v) }
    / v:IntegerString { AST(state).Number(v) }
    / v:TextString { AST(state).Text(v) };
Integer = IntegerString WSO;

KEYWORD = DO / DEF / DB / TRUE / FALSE;

// note: tokens followed by WSC will swallow an EOL
DB = "db" IDX;
DEF = "def" IDX;
DO = "do" IDX;

TRUE = "true" IDX;
FALSE = "false" IDX;
RECURSE = "recurse" IDX;
IF = "if" IDX;
FOLD = "fold" IDX;

//NOT = "not" IDX;
RA = "=>" WSO;
LA = ":=" WSO;
COLON = ':' !OpChar WSO;
SEP = ',' WSC;
DOT = '.' WSO;
LC = '{' WSO;
RC = '}' WSO;   // note: gets its own handling
LP = '(' WSC;
RP = ')' WSO;
LB = '[' WSO;
RB = ']' WSO;
STAR = '*' !OpChar WSO;
QUERY = '?' WSO;
DOLLAR = '$' WSO;
PERCENT = '%' WSO;
MINUS = '-' !OpChar WSO;

IDX = !ID WS*;              // end of ident possibly followed by WS

Skip = (!EOL .)* (EOFX / EOLX);       // skip the rest of the line and hope it then makes sense
WSC = WSO (EOLX WSO)*;      // continuation, take eol if found, plus WS
WSO = WS*;                  // optional whitespace between tokens
WS = (SP / Comment) { "" };
SP = [ \t];
Comment = "//" (!EOL .)*
        / "/*" (!"*/" (EOLX / .))* "*/";

EOLX = &EOL &{ PrintLine(state) } EOL; // consumed EOL, so print it
EOFX = &EOF &{ PrintLine(state) } EOF;
EOL = "\r"? "\n" { "" };
EOF = !.;

// More complex lexical tokens, but not for use as terminals
//TextString = v:(SingleQuoted / DoubleQuoted / CharHexQuoted / CharDecQuoted)+ { String.Concat(v) };

TextString = v:TextQuoted<1,,WSO> { String.Concat(v) };
TextQuoted = SingleQuoted / DoubleQuoted / CharHexQuoted / CharDecQuoted;

// Lexical tokens, not including white space
SingleQuoted = SQ v:("" (!(CC / SQ) . )* ) SQ { v };
DoubleQuoted = DQ v:("" (!(CC / DQ) . )* ) DQ { v };
CharHexQuoted = "h" SQ SP* v:HexDigits<1,,SP+> SP* SQ { NumToStr(v.ToArray(),16) };
//CharHexQuoted = "h" SQ v:("" SP* (HexDigit+ SP*)*) SQ { v };
CharDecQuoted = "d" SQ SP* v:Digits<1,,SP+> SP* SQ { NumToStr(v.ToArray(),10) };
BinaryQuoted  = "b" SQ v:("" HexDigit*) SQ { v };
TimeQuoted    = 't' SQ v:("" (Digit / Letter / TimeChar)+) SQ { v };
NumberString  = '.' Digit+ / Digit+ ('.' Digit*)?;
IntegerString = "" Digit+ / "$" Digit HexDigit*;
IdentQuoted   = "i" SQ v:("" (!CC !SQ .)* ) SQ { v };
IdentString = (Letter / IdChar) (Letter / Digit / IdChar / IdCharX)*;
OpSym = OpChar OpChar?;
ID = Letter / Digit / IdChar / IdCharX;
Digits = v:Digit+ { String.Concat(v) };
HexDigits = v:HexDigit+ { String.Concat(v) };

// character sets (not tokens)
Letter = [a-zA-Z];
Digit = [0-9];
HexDigit = [a-fA-F0-9];
OpChar = [&=<>:~*/+-];
IdChar = [_$@^];
IdCharX = [#%&?!~`];
TimeChar = [: ./-];
CC = [\x00-\x1f];
SQ = "'";
DQ = '"';
