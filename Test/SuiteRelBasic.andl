// Test Suite -- basic testing of relational features

#catalog

start($filename$)

//--- literals

t1 := {name := 'Smith', age := 17} 
assert($lineno$, t1 = {age := 16+1, name := 'Smi''th'})

r1 := {{age := 17, name := 'Smith'}} 
r1a := {{name := 'Smith', age := 17}} 
assert($lineno$, r1 = r1a)
assert($lineno$, r1 = {{age := 1+16, name := 'S'&'mith'}})

r2 := {{name := 'Smith', age := 17},
       {name := 'Jones', age := 35},
       {age :=199,name:='Frankenstein' }} 
assert($lineno$, r2 = {{age := 35, name := 'Jones'},
      {age := 17, name := 'Smith'},
      {name:='Frankenstein',age :=199}})

assert($lineno$, r1 = {{name:'',age:0}('Smith', 17)})
assert($lineno$, r1 = {{name:text,age:number}('Smith', 17)})
assert($lineno$, r2 = {{name:'',age:0}('Smith', 17),('Jones', 35),('Frankenstein',199 )})

//--- set operators, literals

assert($lineno$, r1.count = 1)
assert($lineno$, r2.count = 3)

assert($lineno$, r1 sub r1)
assert($lineno$, r1 sub r2)
assert($lineno$, r2 sup r1)
assert($lineno$, r2 sup r2)
assert($lineno$, r1 sep r2 = false)
assert($lineno$, r2 sep r1 = false)

//--- meta data uses internal table
Smeta0 := {{ Type:'', Name:'' }}
assert($lineno$, Smeta0.count = 0)

Smeta1 := {{ Type:='', Name:='' }}
assert($lineno$, Smeta1.count = 1)

Smeta := {{ Name := 'S#', Type := 'text'}, 
    { Name := 'SNAME', Type := 'text'}, 
    { Name := 'STATUS', Type := 'number'}, 
    { Name := 'CITY', Type := 'text'} }

assert($lineno$, count(Smeta0 union Smeta1 union Smeta) = 5)
assert($lineno$, schema(S) = Smeta)
assert($lineno$, S.schema = Smeta)

//--- set operators, variables
assert($lineno$, count(S) = 5)
assert($lineno$, S.count = 5)

assert($lineno$, S sub S)
assert($lineno$, not(S sub S .where(SNAME='Smith')))
assert($lineno$, S sup S)
assert($lineno$, S sup S .where(SNAME = 'Smith'))
assert($lineno$, S sup S .where(SNAME <> 'Smith'))
assert($lineno$, not(S sep S))
assert($lineno$, S .where(SNAME = 'Smith') sep S .where(SNAME <> 'Smith'))

//--- monadic
assert($lineno$, S .where(true) = S)
assert($lineno$, S .where(false) <> S)
assert($lineno$, S .where(false) = {{STATUS : 0, CITY : '', S# : '', SNAME : ''}})
assert($lineno$, S .where(false) = {{S# := '', SNAME := '', STATUS := 0, CITY := ''}} .where(false))
assert($lineno$, S .where(false) = {{STATUS := 0, CITY := '', S# := '', SNAME := ''}} .where(false))

Sstatus := {{STATUS := 20}, {STATUS := 10}, {STATUS := 30} }
assert($lineno$, S .set{ STATUS } = Sstatus)
assert($lineno$, S .set{ X := STATUS } = Sstatus .set{ X := STATUS })

Ss4 := {{ S# := 'S4', CITY := 'London', STATUS := 020, SNAME := 'Clark' }}
assert($lineno$, S .where(S# = 'S4') = Ss4)
assert($lineno$, count(S .where(SNAME = 'Clark')) = 1)
assert($lineno$, S .where(STATUS = 20) <> Ss4)
assert($lineno$, S .where(STATUS = 20) sup Ss4)
assert($lineno$, count(S .where(STATUS = 20)) = 2)

assert($lineno$, count(S .where(STATUS = 20)) = 2)

//--- skip take
assert($lineno$, S .set { S# } = {{ S# = 'S1', S# = 'S2', S# = 'S3', S# = 'S4', S# = 'S5', }}


//--- function types -- incomplete
_fn1bo(a:bool) => a
_fn1bi(a:binary) => a
_fn1nu(a:number) => a
_fn1te(a:text) => a
_fn1ti(a:time) => a

_fn2bo(a:bool) => not a
_fn2bi(a:binary) => b'05040302'  // no available func
_fn2nu(a:number) => a+1
_fn2te(a:text) => before(a,'world') & 'fred'
_fn2ti(a:time) => t'2016-12-31 23:59:59.999' // no available func

_fn3bo(a:bool) => fold(or,a)
_fn3bi(a:binary) => a // no available func
_fn3nu(a:number) => fold(+,a)
_fn3te(a:text) => fold(&,a)
_fn3ti(a:time) => a // no available func

_r1 := {{ bo:=true, bi:=b'0102030405', nu:=123456789.123456789, te:='hello world', ti:=t'2015-12-31 23:59:59.999' }}
_r2 := {{ bo:=false, bi:=b'05040302', nu:=123456790.123456789, te:='hello fred', ti:=t'2016-12-31 23:59:59.999' }}
_r3 := _r1
R := _r1

assert($lineno$, _r1 = R)
assert($lineno$, _r1 = R .set{ bo := _fn1bo(bo), bi := _fn1bi(bi), nu := _fn1nu(nu), te := _fn1te(te), ti := _fn1ti(ti) })
assert($lineno$, _r2 = R .set{ bo := _fn2bo(bo), bi := _fn2bi(bi), nu := _fn2nu(nu), te := _fn2te(te), ti := _fn2ti(ti) })
assert($lineno$, _r3 = R .set{ bo := _fn3bo(bo), bi := _fn3bi(bi), nu := _fn3nu(nu), te := _fn3te(te), ti := _fn3ti(ti) })

finish($filename$)
